load("yang.rr")$
load("os_muldif.rr")$
load("nk_restriction.rr")$
load("util.rr")$
load("common.rr")$

yang.define_ring(["partial", [y, mu, sig]])$

def pf(I) {
  /* Faster than the code: "G = yang.gr(I)" */
  G = nd_weyl_gr(I, [y, mu, sig, dy, dmu, dsig], 0, poly_r_omatrix(3));

  S = yang.stdmon(G);
  print(S);
  Pf = yang.pf(S, G);
  return Pf;
}

def gen_pfaffian(K, Var_st, Var_ob) {
  Ist = [ dx + (x - K*xp)/Var_st
        , dxp - K*(x - K*xp)/Var_st]$

  Iob = util.gen_obs_eq(y - 2*x/(1+x^2))$

  Iphis = common.gen_ann_phis(Ist, Iob)$

  Pf0s = pf(Iphis[0])$
  Pf1s = pf(Iphis[1])$
  Pf2s = pf(Iphis[2])$

  return [Pf0s, Pf1s, Pf2s];
}

end$
